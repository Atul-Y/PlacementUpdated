===================================================
Fixed-Size Sliding Window Template (Structure)
==================================================


//brute force approach

int n = nums.size();
int windowSize = k;

for (int i = 0; i <= n - windowSize; i++) {
    // â†’ Initialize/reset anything needed for the current window
    //    e.g., sum = 0, max = INT_MIN, freq.clear(), etc.
    
    for (int j = i; j < i + windowSize; j++) {
        // â†’ Process nums[j] for this window
        //    e.g., sum += nums[j], count negative, track max/min etc.
    }

    // â†’ After inner loop finishes, record result for current window
    //    e.g., res.push_back(sum/max/beauty etc.)
}

âš–ï¸ Difference in philosophy
Fixed window brute force â†’ iterate only windows of length k (j runs i..i+k-1).
Variable window brute force â†’ iterate all possible windows starting at i (so j runs till n-1).




ðŸŸ¢ 2. Fixed-Size Sliding Window Template


int i = 0, j = 0;
int n = nums.size();
int windowSize = k;
int sum = 0; // or other variables like max, min, freq map, etc. //we initialize here because we want to maintain the state of the window
while (j < n) {
    // 1. Expand window â†’ include nums[j]
    // e.g., sum += nums[j], freq[nums[j]]++

    // 2. If window size < k, just move forward
    if (j - i + 1 < windowSize) {
        j++;
    }
    // 3. When window size == k
    else if (j - i + 1 == windowSize) {
        // Do your logic here (max/min/sum/freq check/etc.)

        // Before sliding â†’ remove nums[i] effect
        // e.g., sum -= nums[i], freq[nums[i]]--
        i++;
        j++;
    }
}
//we dont see for j-i+1 > k here in fixed window because it will not come only .